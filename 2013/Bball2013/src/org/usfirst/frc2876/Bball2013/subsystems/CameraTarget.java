// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2876.Bball2013.subsystems;

import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.camera.AxisCamera;
import edu.wpi.first.wpilibj.camera.AxisCameraException;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.image.BinaryImage;
import edu.wpi.first.wpilibj.image.ColorImage;
import edu.wpi.first.wpilibj.image.CriteriaCollection;
import edu.wpi.first.wpilibj.image.NIVision;
import edu.wpi.first.wpilibj.image.NIVisionException;
import edu.wpi.first.wpilibj.image.ParticleAnalysisReport;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc2876.Bball2013.RobotMap;
import org.usfirst.frc2876.Bball2013.Target;
import org.usfirst.frc2876.Bball2013.commands.*;

/**
 *
 */
public class CameraTarget extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
        setDefaultCommand(new CameraIdle());



    }
    public static final String[] pos = {"TOP", "RGT", "BOT", "LFT"};
    public static final int TOP = 0;
    public static final int RIGHT = 1;
    public static final int BOT = 2;
    public static final int LEFT = 3;
    String angleHistory;
    // bhs vals
//    int rlow = 50;
//    int glow = 43;
//    int blow = 47;
    int rlow = 70;
    int glow = 40;
    int blow = 25;
    int ghigh = 255;
    int rhigh = 255;
    int bhigh = 255;
// This worked at 7pm on a sunny day (lights off)
//    int rlow = 10;
//    int glow = 40;
//    int blow = 25;
//    int ghigh = 120;
//    int rhigh = 255;
////    int bhigh = 255;
    // arena vals
//    int rlow = 103;
//    int rhigh = 255;
//    int glow = 150;
//    int ghigh = 255;
//    int blow = 26;
//    int bhigh = 255;
    // practice area
//    int rlow = 60;
//    int rhigh = 255;
//    int glow = 80;
//    int ghigh = 255;
//    int blow = 28;
//    int bhigh = 255;
    int VIEW_ANGLE = 54;
    AxisCamera camera;
    CriteriaCollection cc;
    Preferences pfs = Preferences.getInstance();
    boolean filter_running = false;
    Target[] sorted;
    Target none;
    double current_turn = 0;
    double search = 1;
    double search_incr = 0;

    public CameraTarget() {
        //super("CameraTarget");

        camera = AxisCamera.getInstance();

        cc = new CriteriaCollection();
        cc.addCriteria(NIVision.MeasurementType.IMAQ_MT_BOUNDING_RECT_WIDTH, 30, 400, false);
        cc.addCriteria(NIVision.MeasurementType.IMAQ_MT_BOUNDING_RECT_HEIGHT, 40, 400, false);

        pfs.putInt("rlow", rlow);
        pfs.putInt("rhigh", rhigh);
        pfs.putInt("glow", glow);
        pfs.putInt("ghigh", ghigh);
        pfs.putInt("blow", blow);
        pfs.putInt("bhigh", bhigh);
        pfs.putInt("theta", VIEW_ANGLE);
        pfs.save();
        System.out.println("R=" + rlow + "," + rhigh
                + " G=" + glow + "," + ghigh
                + " B=" + blow + "," + bhigh);

        none = new Target(null, 0);
        resetTargets();
        resetLastAngle();
    }


    public void resetLastAngle() {
        angleHistory = "";
    }

    public void addLastAngle(double degrees) {
        angleHistory += ":" + degrees;
    }

    public void printTargets() {
        double pdelay = .2;
        for (int i = 0; i < sorted.length; i++) {
            System.out.println(pos[i] + ": " + sorted[i]);
            Timer.delay(pdelay);
        }
    }

    private void sort2(Target[] targets) {
        if (targets == null || sorted == null) {
            return;
        }
        if (targets.length == 0) {
            return;
        }
        sorted[TOP] = targets[0];
        for (int i = 0; i < targets.length; i++) {
            if (targets[i].getYCoM() < sorted[TOP].getYCoM() || sorted[TOP] == none) {
                sorted[TOP] = targets[i];
            }
        }
        sorted[LEFT] = none;
        for (int i = 0; i < targets.length; i++) {
            if (targets[i].getXCoM() < sorted[LEFT].getXCoM() || sorted[LEFT] == none) {
                sorted[LEFT] = targets[i];
            }
        }
        sorted[RIGHT] = none;
        for (int i = 0; i < targets.length; i++) {
            if (targets[i].getXCoM() > sorted[RIGHT].getXCoM() || sorted[RIGHT] == none) {
                sorted[RIGHT] = targets[i];
            }
        }
        sorted[BOT] = none;
        for (int i = 0; i < targets.length; i++) {
            if (targets[i].getYCoM() > sorted[BOT].getYCoM() || sorted[BOT] == none) {
                sorted[BOT] = targets[i];
            }
        }

    }

    private void analyzeImage(BinaryImage img) {
        Target[] targets = null;
        try {
            ParticleAnalysisReport[] reports = img.getOrderedParticleAnalysisReports();
            System.out.println("num particles " + reports.length);
            targets = new Target[4];
            for (int i = 0; i < targets.length; i++) {
                targets[i] = none;
            }
            Target[] tmp = new Target[reports.length];
            int valid = 0;
            for (int i = 0; i < reports.length; i++) {
                Target t = new Target(reports[i], VIEW_ANGLE);
                t.analyze();
                if (t.isValid()) {
                    tmp[i] = t;
                    valid++;
                } else {
                    System.out.println("invalid: " + t);
                    tmp[i] = none;
                }
            }
            targets = new Target[valid];
            for (int i = 0, j = 0; i < tmp.length && j < valid; i++) {
                if (tmp[i] != none) {
                    targets[j] = tmp[i];
                    j++;
                }
            }
            sorted = new Target[4];
            for (int i = 0; i < sorted.length; i++) {
                sorted[i] = none;
            }

            sort2(targets);
            current_turn = getBestTarget().getTurnDegrees();

        } catch (NIVisionException ex) {
            ex.printStackTrace();
        }

    }

    private void printParticleReports(BinaryImage img) {
        double pdelay = .1;
        try {
            ParticleAnalysisReport[] reports =
                    img.getOrderedParticleAnalysisReports();
            for (int i = 0; i < reports.length && i < 5; i++) {
                ParticleAnalysisReport r = reports[i];
                System.out.println("Particle(" + (i + 1) + "/" + reports.length
                        + ")");
                Timer.delay(pdelay);
                System.out.println(" left=" + r.boundingRectLeft
                        + " top=" + r.boundingRectTop
                        + " x=" + r.center_mass_x
                        + " y=" + r.center_mass_y);
                Timer.delay(pdelay);
            }
            System.out.println(img.getNumberParticles()
                    + "  " + Timer.getFPGATimestamp());
            Timer.delay(pdelay);
        } catch (NIVisionException ex) {
            ex.printStackTrace();
        }
    }

    public boolean isFilterRunning() {
        return filter_running;
    }
    int img_ctr = 0;
    int MAX_SAVE = 5;

    public void findTargets(boolean saveImage) {
        filter_running = true;
        try {
            resetTargets();
            if (camera.freshImage() == false) {
                filter_running = false;
                return;
            }

            rlow = pfs.getInt("rlow", 0);
            rhigh = pfs.getInt("rhigh", 0);
            glow = pfs.getInt("glow", 0);
            ghigh = pfs.getInt("ghigh", 0);
            blow = pfs.getInt("blow", 0);
            bhigh = pfs.getInt("bhigh", 0);
            VIEW_ANGLE = pfs.getInt("theta", 54);

            ColorImage image = camera.getImage();
            if (saveImage && img_ctr < MAX_SAVE) {
                image.write("/tmp/" + img_ctr + "_0raw-image.png");
            }

            BinaryImage thresholdImage = image.thresholdHSL(rlow, rhigh,
                    glow, ghigh, blow, bhigh);
            if (saveImage) {
                System.out.println("R=" + rlow + "," + rhigh
                        + " G=" + glow + "," + ghigh
                        + " B=" + blow + "," + bhigh);
            }
            if (saveImage && img_ctr < MAX_SAVE && img_ctr < 5) {
                thresholdImage.write("/tmp/" + img_ctr + "1thresh-image.png");
            } // remove small artifacts
            BinaryImage bigObjectsImage = thresholdImage.removeSmallObjects(false, 1);
            if (saveImage && img_ctr < MAX_SAVE) {
                bigObjectsImage.write("/tmp/" + img_ctr + "2big-image.png");
            } // fill in occluded rectangles
            BinaryImage convexHullImage = bigObjectsImage.convexHull(false);
            if (saveImage && img_ctr < MAX_SAVE) {
                convexHullImage.write("/tmp/" + img_ctr + "3convex-image.png");
            } // find filled in rectangles
            BinaryImage filteredImage = convexHullImage.particleFilter(cc);
            if (saveImage && img_ctr < MAX_SAVE) {
                filteredImage.write("/tmp/" + img_ctr + "4filter-image.png");
            }
            if (saveImage) {
                printParticleReports(filteredImage);
            }
            //img_ctr++;
            analyzeImage(filteredImage);

            filteredImage.free();
            convexHullImage.free();
            bigObjectsImage.free();
            thresholdImage.free();
            image.free();
        } catch (AxisCameraException ex) {
            ex.printStackTrace();
        } catch (NIVisionException ex) {
            ex.printStackTrace();
        }
        filter_running = false;
    }

    // Get the first available target. If target is not found during image
    // analysis the sorted array gets set to 'none' Target object which
    // returns default values (probably zero) for distance and turn amount.
    private Target getBestTarget() {
        Target t = none;
        if (sorted != null) {
            if (sorted[TOP] != none) {
                t = sorted[TOP];
            } else if (sorted[BOT] != none) {
                t = sorted[BOT];
            } else if (sorted[LEFT] != none) {
                t = sorted[LEFT];
            } else if (sorted[RIGHT] != none) {
                t = sorted[RIGHT];
            }
        }
        return t;
    }

    public void resetTargets() {
        if (sorted == null) {
            sorted = new Target[4];
        }
        for (int i = 0; i < sorted.length; i++) {
            sorted[i] = none;
        }
    }

    public double getTurnAmount() {
        Target t = getBestTarget();
        if (t == none) {
            current_turn = 0;
//            search_incr++;
//            if (search > 0) {
//                search = 25 * search_incr * -1;
//            } else {
//                search = 25 * search_incr;
//            }
//            if (search > 180) {
//                search = 0;
//            }
//            current_turn = search;
        } else {
            search_incr = 0;
            current_turn = getBestTarget().getTurnDegrees();
        }
        return current_turn;
    }

    public double getDistance() {
        return getBestTarget().getDistance();
    }
}
